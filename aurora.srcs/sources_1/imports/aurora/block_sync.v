// Module block_sync_sm
// Generated by Xilinx Aurora 64B66B

`define DLY #0
module block_sync #
(
    parameter      SH_CNT_MAX         = 16'd64,
    parameter      SH_INVALID_CNT_MAX = 10'd16
)
(
    // System Interface
    input          clk,
    input          system_reset,
    
    // User Interface
    output reg     blocksync_out,
    output reg     rxgearboxslip_out,
    input    [1:0] rxheader_in,
    input          rxheadervalid_in
);

reg         next_begin_c;
reg         next_sh_invalid_c;
reg         next_sh_valid_c;
reg         next_slip_c;
reg         next_sync_done_c;
reg         next_test_sh_c;
wire        sh_count_equals_max_i;
wire        sh_invalid_cnt_equals_max_i;
wire        sh_invalid_cnt_equals_zero_i;
wire        slip_done_i;
wire        sync_found_i;

reg         begin_r;
reg         sh_invalid_r;
reg         sh_valid_r;
//reg  [99:0] slip_count_i;   //EDITED
reg  [15:0] slip_count_i;   //EDITED
reg         slip_r;
reg         sync_done_r;
reg  [15:0] sync_header_count_i;
reg   [9:0] sync_header_invalid_count_i;
reg         test_sh_r;

reg         system_reset_r;
reg         system_reset_r2;

assign sync_found_i   = (rxheader_in == 2'b01) || (rxheader_in == 2'b10);

// Double Synchronize system_reset wrt clk
always @(posedge clk)
begin
    system_reset_r     <=  `DLY   system_reset;
    system_reset_r2    <=  `DLY   system_reset_r;
end

//________________________________ State machine __________________________

// State registers
always @(posedge clk)
    if(system_reset_r2)
        {begin_r,test_sh_r,sh_valid_r,sh_invalid_r,slip_r,sync_done_r}  <=  `DLY    6'b100000;
    else
    begin
        begin_r          <=  `DLY    next_begin_c;
        test_sh_r        <=  `DLY    next_test_sh_c;
        sh_valid_r       <=  `DLY    next_sh_valid_c;
        sh_invalid_r     <=  `DLY    next_sh_invalid_c;
        slip_r           <=  `DLY    next_slip_c;
        sync_done_r      <=  `DLY    next_sync_done_c;
    end

// FSM is same as above, but recoded as priority muxes

localparam BEGIN_R_ST     = 6'b100000,
           TEST_SH_ST     = 6'b010000,
           SH_VALID_ST    = 6'b001000,
           SH_INVALID_ST  = 6'b000100,
           SLIP_R_ST      = 6'b000010,
           SYNC_DONE_R_ST = 6'b000001;

always @(*) begin
    {next_begin_c,next_test_sh_c,next_sh_valid_c,next_sh_invalid_c,next_slip_c,next_sync_done_c} = 6'b000000;

    case({begin_r,test_sh_r,sh_valid_r,sh_invalid_r,slip_r,sync_done_r})
        BEGIN_R_ST: begin
            next_test_sh_c = 1'b1;
        end
        TEST_SH_ST: begin
            if(rxheadervalid_in) begin
                if(sync_found_i)
                    next_sh_valid_c = 1'b1;
                else
                    next_sh_invalid_c = 1'b1;
            end
            else
                next_test_sh_c = 1'b1;
        end
        SH_VALID_ST: begin
            if(sh_count_equals_max_i) begin
                if(sh_invalid_cnt_equals_zero_i)
                    next_sync_done_c = 1'b1;
                else if((sh_invalid_cnt_equals_max_i | !blocksync_out))
                    next_slip_c = 1'b1;
                else
                    next_begin_c = 1'b1;
            end
            else
                next_test_sh_c = 1'b1;
        end
        SH_INVALID_ST: begin
            if(sh_invalid_cnt_equals_max_i)
                next_slip_c = 1'b1;
            else begin
                if(!blocksync_out)
                    next_slip_c = 1'b1;
                else if(sh_count_equals_max_i)
                    next_begin_c = 1'b1;
                else
                    next_test_sh_c = 1'b1;
            end
        end
        SLIP_R_ST: begin
            if(slip_done_i)
                next_begin_c =1'b1;
            else
                next_slip_c = 1'b1;
        end
        SYNC_DONE_R_ST: begin
            next_begin_c = 1'b1;
        end
        default: begin
            next_begin_c = 1'b1;
        end
    endcase
end


//________________ Counter keep track of sync headers counted _____________

always @(posedge clk)
    if(begin_r) begin
        sync_header_count_i   <=  `DLY    16'd0;
    end
    else if (sh_valid_r || sh_invalid_r) begin
        sync_header_count_i  <=  `DLY    sync_header_count_i + 16'd1;
    end

assign sh_count_equals_max_i = (sync_header_count_i==SH_CNT_MAX);

//________________ Counter keep track of invalid sync headers  ____________

always @(posedge clk)
    if(begin_r) begin
        sync_header_invalid_count_i   <=  `DLY    10'd0;
    end
    else if (sh_invalid_r) begin
        sync_header_invalid_count_i  <=  `DLY    sync_header_invalid_count_i + 10'd1;
    end

// signal to indicate max number of invalid sync headers has been reached
assign sh_invalid_cnt_equals_max_i  = (sync_header_invalid_count_i==SH_INVALID_CNT_MAX);

// signal to indicate no invalid sync headers
assign sh_invalid_cnt_equals_zero_i = (sync_header_invalid_count_i==0);

//_______ Counter wait for 16 cycles to ensure that slip is complete _______

assign slip_pulse_i = next_slip_c && !slip_r;

always @(posedge clk)
    rxgearboxslip_out   <=  slip_pulse_i;

//_____________ Ouput assignment to indicate block sync complete  _________

// always @(posedge clk)
//     if(!slip_r) slip_count_i   <=  `DLY    100'h0000;
//     else        slip_count_i   <=  `DLY    {slip_count_i[98:0],rxgearboxslip_out};
// 
// assign slip_done_i = slip_count_i[99];

always @(posedge clk)
    if(!slip_r) slip_count_i   <=  `DLY    16'h0000;
    else        slip_count_i   <=  `DLY    {slip_count_i[14:0],rxgearboxslip_out};

assign slip_done_i = slip_count_i[15];

//_____________ Pulse GEARBOXSLIP port to slip the data by 1 bit  _________

always @(posedge clk)
    if(system_reset_r2 || slip_r)  blocksync_out   <=  `DLY    1'b0;
    else if (sync_done_r)       blocksync_out   <=  `DLY    1'b1;

endmodule
